<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Je2ry&#39;s Blog</title>
  
  
  <link href="http://github.com/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2022-03-30T10:31:10.158Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Je2ry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode刷题笔记</title>
    <link href="http://github.com/2022/03/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://github.com/2022/03/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-29T14:28:57.000Z</published>
    <updated>2022-03-30T10:31:10.158Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>704 二分查找]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分  O(logN) O(1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left,right,mid;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid])</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>278 第一个错误的版本</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right=n;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;<span class="comment">//防溢出</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isBadVersion</span>(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>35 搜索插入位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left,right,mid;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>977 有序数组的平方</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//双指针   O(N)   O(1)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>,pos=n<span class="number">-1</span>;i&lt;=j;)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])</span><br><span class="line">           &#123;</span><br><span class="line">               ans[pos]=nums[i]*nums[i];</span><br><span class="line">               ++i;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               ans[pos]=nums[j]*nums[j];</span><br><span class="line">               --j;</span><br><span class="line">           &#125;</span><br><span class="line">           --pos;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//暴力   O(NlogN)  O(logN)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num * num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());<span class="comment">//sort是快排的优化。O(nlogn)</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>344 反转字符串</li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;i&lt;=j;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> tmp=s[i];</span><br><span class="line">            s[i]=s[j];</span><br><span class="line">            s[j]=tmp;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//双指针   可直接用swap()函数。</span></span><br></pre></td></tr></table></figure><ol start="6"><li><p>27 移除元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针 O(N) O(1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>;fast&lt;nums.<span class="built_in">size</span>();fast++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(val!=nums[fast])</span><br><span class="line">             nums[slow++]=nums[fast];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209长度最小的子数组</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法 O(n^2) O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//滑动窗口 O(N) O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;   sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)</span><br><span class="line">            &#123;   length=j-i+<span class="number">1</span>;</span><br><span class="line">                res=res&lt;length?res:length;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==INT32_MAX?<span class="number">0</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59 螺旋矩阵II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><hr><ol start="9"><li><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203 移除链表元素</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代  O(N)   O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode * vhead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode *p=vhead;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val==val)&#123;</span><br><span class="line">        </span><br><span class="line">                p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>理论基础</li></ol><ul><li>数组是存放在连续内存空间上的相同类型数据的集合</li><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的，删除或者增添元素的时候，就难免要移动其他元素的地址。</li><li>数组的元素是不能删的，只能覆盖。</li><li>C++中二维数组的在地址空间上是连续的,java不是。</li></ul><ol start="2"><li><p>二分查找</p><p>数组为<strong>有序数组</strong>，同时题目还强调数组中<strong>无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right]</strong></p><p>while(left&lt;&#x3D;right)</p><p>第二种写法，定义 target 是在一个在左闭右开的区间里，也就是[left, right) </p><p>while(left&lt;right)</p><p>相关题目:35(A). 34. 69. 367.</p></li><li><p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</p><p>相关题目:26. 283. 844. 977.(A) </p></li><li><p><strong>滑动窗口</strong></p><p>​    所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>相关题目:904.76.209.(A)</p></li><li><p>模拟类题目</p><p>相关题目:54. 59. 剑指29.</p></li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><p>单链表</p></li><li><p>双链表</p></li><li><p>循环链表：可以用于解决约瑟夫环问题</p><p><strong>链表定义</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不定义构造函数也行，c++会默认生成一个构造函数，但不会初始化任何成员变量</span></span><br><span class="line"></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);<span class="comment">//通过自己定义的构造初始化</span></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;<span class="comment">//使用默认构造初始化结点，初始化的时候不能直接给变量赋值。</span></span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>满二叉树</strong></p><p>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p><strong>完全二叉树</strong></p><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p><p>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</p><p><strong>二叉搜索树</strong></p><p>二叉搜索树是一个有序树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><strong>平衡二叉树</strong></p><p>AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。</p><p><strong>存储方式</strong></p><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p><p>用数组来存储二叉树如何遍历的呢？</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p><strong>遍历方式</strong></p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p><strong>二叉树的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;704 二分查找]&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="C++" scheme="http://github.com/categories/C/"/>
    
    <category term="Algorithm" scheme="http://github.com/categories/C/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>C++面试题</title>
    <link href="http://github.com/2022/03/29/C-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://github.com/2022/03/29/C-%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2022-03-28T18:57:12.000Z</published>
    <updated>2022-03-29T06:22:22.084Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>某文件中定义的静态全局变量，作用域为(<strong>本文件</strong>)</p></li><li><p>如何判断一道程序由C还是C++编译器编译的</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;c++&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>C++函数的传递方式有哪些</p><p>值传递、指针传递和引用传递。</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;某文件中定义的静态全局变量，作用域为(&lt;strong&gt;本文件&lt;/strong&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何判断一道程序由C还是C++编译器编译的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
   &lt;figure class=&quot;highlight c++&quot;</summary>
      
    
    
    
    <category term="C++" scheme="http://github.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>some notes</title>
    <link href="http://github.com/2022/03/24/some-notes/"/>
    <id>http://github.com/2022/03/24/some-notes/</id>
    <published>2022-03-24T04:21:36.000Z</published>
    <updated>2022-03-24T08:04:58.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CMake-的命令行调用"><a href="#CMake-的命令行调用" class="headerlink" title="CMake 的命令行调用"></a>CMake 的命令行调用</h3><blockquote><p>读取当前目录的 CMakeLists.txt，并在 build 文件夹下生成 build&#x2F;Makefile：</p><p>cmake -B build</p><p>让 make 读取 build&#x2F;Makefile，并开始构建 a.out：<br>make -C build<br>以下命令和上一个等价，但更跨平台：<br>cmake –build build<br>执行生成的 a.out：<br>build&#x2F;a.out</p></blockquote><h3 id="库-Library"><a href="#库-Library" class="headerlink" title="库(Library)"></a>库(Library)</h3><p>有时候我们会有多个可执行文件，他们之间用到的某些功能是相同的，我们想把这些共用的功能做成一个库，方便大家一起共享。<br>库中的函数可以被可执行文件调用，也可以被其他库文件调用。<br>库文件又分为<strong>静态库文件</strong>和<strong>动态库文件</strong>。<br>其中<strong>静态库</strong>相当于<strong>直接把代码插入到生成的可执行文件中</strong>，会导致体积变大，但是只需要一个文件即可运行。<br>而<strong>动态库</strong>则只在生成的可执行文件中生成“插桩”函数，当可执行文件被加载时会读取指定目录中的.dll文件，加载到内存中空闲的位置，并且替换相应的“插桩”指向的地址为加载后的地址，这个过程称为重定向。这样以后函数被调用就会跳转到动态加载的地址去。<br>Windows：可执行文件同目录，其次是环境变量%PATH%<br>Linux：ELF格式可执行文件的RPATH，其次是&#x2F;usr&#x2F;lib等</p><p><strong>cmake中的静态库和动态库</strong></p><p>CMake 除了 add_executable 可以生成可执行文件外，还可以通过 add_library 生成库文件。<br>add_library 的语法与 add_executable 大致相同，除了他需要指定是动态库还是静态库：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成静态库libtest.a</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">test</span> STATIC <span class="number">01</span>.cpp <span class="number">02</span>.cpp)</span><br><span class="line"><span class="comment">#生成动态库libtest.so</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">test</span> SHARED <span class="number">01</span>.cpp <span class="number">02</span>.cpp)</span><br></pre></td></tr></table></figure><p>创建库以后，要在某个可执行文件中使用该库，只需要：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为 myexec 链接刚刚制作的库 libtest.a</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myexec PUBLIC <span class="keyword">test</span>) </span><br><span class="line">PUBLIC的含义：</span><br></pre></td></tr></table></figure><p>![image-20220324123741987](&#x2F;Users&#x2F;fengjiarui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220324123741987.png)</p><p>cstdio 也无非是提供了 printf 等一系列函数声明的头文件而已，实际的实现是在 libc.so 这个动态库里。其中 <cstdio> 这种形式表示不要在当前目录下搜索，只在系统目录里搜索，”hello.h” 这种形式则优先搜索当前目录下有没有这个文件，找不到再搜索系统目录。</p><p>此外，在实现的文件 hello.cpp 中也导入声明的文件 hello.h 是个好习惯：<br>可以保证当 hello.cpp 被修改时，比如改成 hello(int)，编译器能够发现 hello.h 声明的 hello() 和定义的 hello(int) 不一样，避免“沉默的错误”（虽然对支持重载的 C++ 不奏效）<br>可以让 hello.cpp 中的函数需要相互引用时，不需要关心定义的顺序</p><p>![image-20220324125431350](&#x2F;Users&#x2F;fengjiarui&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220324125431350.png)</p><p>但是这样造成一个问题，就是如果多个头文件都引用了 MyClass.h，那么 MyClass 会被重复定义两遍。</p><p>解决方案：在头文件前面加上一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure><p>这样当预处理器第二次读到同一个文件时，就会自动跳过<br>通常头文件都不想被重复导入，因此建议在每个头文件前加上这句话。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##除了头文件搜索目录以外，还有这些选项，PUBLIC 和 PRIVATE 对他们同理：</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(myapp PUBLIC /usr/<span class="keyword">include</span>/eigen3)  <span class="comment"># 添加头文件搜索目录</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp PUBLIC hellolib)                               <span class="comment"># 添加要链接的库</span></span><br><span class="line">target_add_definitions(myapp PUBLIC MY_MACRO=<span class="number">1</span>)             <span class="comment"># 添加一个宏定义</span></span><br><span class="line">target_add_definitions(myapp PUBLIC -DMY_MACRO=<span class="number">1</span>)         <span class="comment"># 与 MY_MACRO=1 等价</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(myapp PUBLIC -fopenmp)                     <span class="comment"># 添加编译器命令行选项</span></span><br><span class="line"><span class="keyword">target_sources</span>(myapp PUBLIC hello.cpp other.cpp)                    <span class="comment"># 添加要编译的源文件</span></span><br><span class="line">以及可以通过下列指令（不推荐使用），把选项加到所有接下来的目标去：</span><br><span class="line"><span class="keyword">include_directories</span>(/opt/cuda/<span class="keyword">include</span>)     <span class="comment"># 添加头文件搜索目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(/opt/cuda)                       <span class="comment"># 添加库文件的搜索路径</span></span><br><span class="line"><span class="keyword">add_definitions</span>(MY_MACRO=<span class="number">1</span>)             <span class="comment"># 添加一个宏定义</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-fopenmp)             <span class="comment"># 添加编译器命令行选项</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>有时候我们不满足于 C++ 标准库的功能，难免会用到一些第三方库。</li><li>最友好的一类库莫过于纯头文件库了，这里是一些好用的 header-only 库：</li></ul><ol><li>nothings&#x2F;stb - 大名鼎鼎的 stb_image 系列，涵盖图像，声音，字体等，只需单头文件！</li><li>Neargye&#x2F;magic_enum - 枚举类型的反射，如枚举转字符串等（实现方式很巧妙）</li><li>g-truc&#x2F;glm - 模仿 GLSL 语法的数学矢量&#x2F;矩阵库（附带一些常用函数，随机数生成等）</li><li>Tencent&#x2F;rapidjson - 单纯的 JSON 库，甚至没依赖 STL（可定制性高，工程美学经典）</li><li>ericniebler&#x2F;range-v3 - C++20 ranges 库就是受到他启发（完全是头文件组成）</li><li>fmtlib&#x2F;fmt - 格式化库，提供 std::format 的替代品（需要 -DFMT_HEADER_ONLY）</li><li>gabime&#x2F;spdlog - 能适配控制台，安卓等多后端的日志库（和 fmt 冲突！）</li></ol><ul><li>只需要把他们的 include 目录或头文件下载下来，然后 include_directories(spdlog&#x2F;include) 即可。</li><li>缺点：函数直接实现在头文件里，没有提前编译，从而需要重复编译同样内容，编译时间长。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CMake-的命令行调用&quot;&gt;&lt;a href=&quot;#CMake-的命令行调用&quot; class=&quot;headerlink&quot; title=&quot;CMake 的命令行调用&quot;&gt;&lt;/a&gt;CMake 的命令行调用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;读取当前目录的 CMakeList</summary>
      
    
    
    
    <category term="Cmake" scheme="http://github.com/categories/Cmake/"/>
    
    <category term="C++" scheme="http://github.com/categories/Cmake/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Cmake相关</title>
    <link href="http://github.com/2022/03/24/Cmake%E7%9B%B8%E5%85%B3/"/>
    <id>http://github.com/2022/03/24/Cmake%E7%9B%B8%E5%85%B3/</id>
    <published>2022-03-24T02:51:13.000Z</published>
    <updated>2022-03-24T08:04:51.631Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 古代 CMake  Cmake 2.x</span></span><br><span class="line"></span><br><span class="line">mkdir -p build </span><br><span class="line">cd build</span><br><span class="line">cmake .. -DCMAKE_BUILD_TYPE = Release  <span class="comment">#在build目录运行cmake&lt;源码目录&gt; 生成Makefile</span></span><br><span class="line">make -j4   <span class="comment">#执行本地的构建系统 make真正开始构建(4进程并行)</span></span><br><span class="line">make <span class="keyword">install</span> </span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line"><span class="comment">#现代 Cmake  CMake 3.x</span></span><br><span class="line"></span><br><span class="line">cmake -B build -DCMAKE_BUILD_TYPE =Release</span><br><span class="line">cmake --build build --parallel <span class="number">4</span></span><br><span class="line">cmake --build build --<span class="keyword">target</span> <span class="keyword">install</span></span><br></pre></td></tr></table></figure><p><strong>现代CMake提供了更方便的 -B和 –build 指令，不同平台，命令统一</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cmake -B bulid</span><br><span class="line"><span class="comment">##1.配置阶段(configure) -B build</span></span><br><span class="line"><span class="comment">#在源码目录用 -B直接创建build目录并生成 build/Makefile 也有可能是.sln</span></span><br><span class="line"><span class="comment">#免去了先创建build目录再切换进去再指定源码目录的麻烦</span></span><br><span class="line">cmake --build build -j4</span><br><span class="line"><span class="comment">##2.构建阶段(build) --build build</span></span><br><span class="line"><span class="comment">#自动调用本地的构建系统在build里构建，即:make -C build -j4</span></span><br><span class="line"><span class="comment">#Linux上调用make,Windows调用devenv.exe</span></span><br><span class="line">suduo cmake --build build --<span class="keyword">target</span> <span class="keyword">install</span></span><br><span class="line"><span class="comment">#调用本地的构建系统执行install 安装 </span></span><br></pre></td></tr></table></figure><p>在配置阶段可以通过**-D选项 设置缓存变量(配置变量)**</p><p>第二次配置时，之前的-D添加仍会被保留。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DCMAKE_INSTALL_PREFIX=/opt/openvdb-<span class="number">8.0</span></span><br><span class="line"><span class="comment">#设置安装路径</span></span><br><span class="line">cmake -B build -DCMAKE_BUILD_TYPE=Release</span><br><span class="line"><span class="comment">#设置构建模式为发布模式(开启全部优化)</span></span><br></pre></td></tr></table></figure><p><strong>-G选项：指定要用的生成器</strong></p><p>Linux默认Unix Makefiles 生成器，常用Ninja，高性能更快。</p><p>Windows默认VS2019生成器。MacOS系统默认Xcode生成器。</p><p>Ninja可跨平台。可从包管理器里安装，windows可用Python的包管理器安装:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ninja</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -G Ninja</span><br></pre></td></tr></table></figure><p> MSBuild单核心构建系统，Makefile多核心但因历史兼容原因效率一般。</p><p>N卡公司cuda强制用msbuild构建。</p><p>cmake看来编译和链接是在一起的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight cmake&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="编译相关" scheme="http://github.com/categories/%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux c++通信架构实战笔记</title>
    <link href="http://github.com/2022/03/23/Linux-c-%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://github.com/2022/03/23/Linux-c-%E9%80%9A%E4%BF%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-23T15:05:07.000Z</published>
    <updated>2022-03-28T16:10:21.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>​    Nginx是一个轻量级(运行时需要的系统资源较少)Web服务器，还有反向代理，负载均衡，邮件代理等功能。</p><p>​    俄罗斯人用C语言开发。可以处理百万级别的TCP连接，运行稳定，可以热部署(运行的时候升级)，可以用C++开发第三方模块增强它的功能。Nginx在Linux上也是通过epoll实现高并发的。Nginx源码值得学习。(内存池，进程池，事件驱动)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//安装nginx准备工作。</span><br><span class="line">//1.查看内核版本，Nginx要求内核2.6及以上</span><br><span class="line">uname -a</span><br><span class="line">//2.安装g++,gcc</span><br><span class="line">//3.PCRE库，用于支持解析正则表达式的函数库。</span><br><span class="line">//采用默认路径</span><br><span class="line">sudo apt-get install libpcre3-dev //ubuntu</span><br><span class="line">//4.zlib库 实现压缩解压缩功能。</span><br><span class="line">sudo apt-get install libz-dev</span><br><span class="line">//5.openssl.ssl功能相关的库，用于网站加密通信(默认情况下Nginx编译用不到)</span><br><span class="line">sudo apt-get install libssl-dev</span><br></pre></td></tr></table></figure><p>​    官网:nginx.org</p><ol><li><p>mainline 主线版本 中间数字为奇数，更新快</p></li><li><p>stable 稳定版 中间数字偶数 </p></li><li><p>Legacy 遗留版</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//源码安装,一般采用稳定版 nginx-1.16.1为例子</span><br><span class="line">mkdir nginxsourcecode</span><br><span class="line">cd nginxsourcecode</span><br><span class="line">wget 下载链接</span><br><span class="line">ls -la查看</span><br><span class="line">tar -xzvf nginx-1.16.1.tar.gz //解压</span><br><span class="line">cd auto 目录可以查看目录结构</span><br></pre></td></tr></table></figure><ul><li><p>conf目录，默认的配置文件。</p></li><li><p>configure文件</p></li><li><p>contrib目录  有vim高亮工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -r contrib/vim ~/.vim //让vim语法高亮显示</span><br><span class="line">-r表示复制目录里所有内容</span><br></pre></td></tr></table></figure></li><li><p>html目录 50x.html和index.html</p></li><li><p>man目录 帮助文件目录</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man ./nginx.8</span><br></pre></td></tr></table></figure><ul><li><p>src目录  最核心的目录，是源代码目录。</p><ul><li>core 核心代码</li></ul><ul><li><p>event 事件模块相关代码</p></li><li><p>http http模块相关代码</p></li><li><p>mail    邮件模块相关</p></li><li><p>os    os相关</p></li><li><p>stream 流处理</p></li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure   //后➕ --help可以查看configure支持的参数</span><br><span class="line">// ./表示当前目录 ../表示上一级目录</span><br><span class="line">make //编译</span><br><span class="line">sudo make install// 安装</span><br></pre></td></tr></table></figure><h4 id="终端与进程的关系"><a href="#终端与进程的关系" class="headerlink" title="终端与进程的关系"></a>终端与进程的关系</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep bash</span><br><span class="line">//进程查看命令，查看包含bash字样的进程。</span><br><span class="line">whereis bash//查找bash可执行程序位置</span><br><span class="line">ps -la</span><br></pre></td></tr></table></figure><p>pid为1的进程就是init进程。</p><p>进程组，表示1个或多个进程的集合。每个进程有一个唯一的进程组ID，一个进程组中的各个进程可以独立接收来自终端的各种信号。可以通过调用系统函数创建进程组，加入进程组等。</p><p>会话(session)，是1个或多个进程组的集合。session leader 创建这个会话的进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,sid,tty,pgrp,comm|grep -E &#x27;bash|PID|nginx&#x27;</span><br><span class="line">//e表示显示所有进程,o表示可以自己指定显示哪些列  sid---session id ,tty表示终端,pgrp表示进程组,comm表示执行的命令。 -E表示开启扩展正则表达式功能。 用于配合后面的bash|PID|nginx 表示某个出现就会被显示。</span><br></pre></td></tr></table></figure><p>strike可用于跟踪程序执行时进程的系统调用(system call)和所接收到的信号。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo strace -e trace=signal -p 1157</span><br><span class="line">//跟踪pid为1157的进程上与信号有关的系统调用。</span><br></pre></td></tr></table></figure><p><strong>终端关闭时如何让进程不退出</strong></p><ol><li>拦截SIGHUP信号。</li><li>nginx进程和bash进程在不同的session中</li></ol><p>setsid不但是个函数，也是个命令。用于启动一个进程，而且能使启动的进程在一个新的session中，这样终端关闭时进程不会退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//例</span><br><span class="line">setsid ./nginx</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>一个进程运行起来之后默认就自动启动了一个主线程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h3&gt;&lt;p&gt;​    Nginx是一个轻量级(运行时需要的系统资源较少)Web服务器，还有反向代理，负载均衡，邮件代理等功能。&lt;</summary>
      
    
    
    
    <category term="C++" scheme="http://github.com/categories/C/"/>
    
    <category term="Linux" scheme="http://github.com/categories/C/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>new/delete and malloc/free</title>
    <link href="http://github.com/2022/03/23/new-delete-and-malloc-free/"/>
    <id>http://github.com/2022/03/23/new-delete-and-malloc-free/</id>
    <published>2022-03-23T13:58:36.000Z</published>
    <updated>2022-03-23T14:00:44.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-x2F-delete和malloc-x2F-free的区别"><a href="#new-x2F-delete和malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free的区别"></a>new&#x2F;delete和malloc&#x2F;free的区别</h3><ol><li><p>new是关键字（也是操作符），需要编译器支持，malloc是库函数，需要头文件支持。</p></li><li><p>参数。new申请内存空间不需要指定大小，malloc需要显示的指定内存大小。</p></li><li><p>返回类型。new分配内存成功返回的是对象类型的指针，不需要类型转换，new是符合类型安全性的操作符。malloc内存分配成功返回void*,需要强制类型转换，将void*指针转换成我们需要的类型。</p></li><li><p>分配失败。new分配失败抛出bac_alloc异常。malloc返回NULL。</p></li><li><p>自定义类型。new会先调用operator new函数申请足够的内存(底层由malloc实现)。然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构，在调用operator delete函数释放内存(通常底层使用free实现)。malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></li><li><p>重载。new&#x2F;delete可以操作符重载，malloc不行</p></li><li><p>内存区域。new操作符从自由存储区(free store)上为对象动态分配内存空间，而malloc函数是从堆区分配内存。</p></li></ol><hr><h4 id="Free-Store-VS-Heap"><a href="#Free-Store-VS-Heap" class="headerlink" title="Free Store VS Heap"></a>Free Store VS Heap</h4><p>C++中，内存分为堆，栈，自由存储区，全局&#x2F;静态存储区，常量存储区。<br>堆是C和OS的术语，因为基本上所有的C++编译器默认使用堆来实现自由存储，即缺省的new和delete由malloc和free实现，这时候new分配的对象，说它在堆上也对，自由存储区也对（此时heap&#x3D;free store)。但如果使用操作符重载的方式，改用其他内存实现自由存储。这时候new的对象就在自由存储区，而不是堆了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-x2F-delete和malloc-x2F-free的区别&quot;&gt;&lt;a href=&quot;#new-x2F-delete和malloc-x2F-free的区别&quot; class=&quot;headerlink&quot; title=&quot;new&amp;#x2F;delete和malloc&amp;#x2</summary>
      
    
    
    
    <category term="C++" scheme="http://github.com/categories/C/"/>
    
    
  </entry>
  
</feed>
