<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Je2ry&#39;s Blog</title>
  
  
  <link href="http://github.com/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2022-05-02T21:44:54.216Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Je2ry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tree</title>
    <link href="http://github.com/2022/05/03/Tree/"/>
    <id>http://github.com/2022/05/03/Tree/</id>
    <published>2022-05-02T21:44:54.000Z</published>
    <updated>2022-05-02T21:44:54.216Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://github.com/2022/05/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://github.com/2022/05/02/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-05-02T12:55:21.000Z</published>
    <updated>2022-05-02T19:19:58.415Z</updated>
    
    <content type="html"><![CDATA[<h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;i++,j--)&#123;</span><br><span class="line">            <span class="type">char</span> temp=s[j];</span><br><span class="line">            s[j]=s[i];</span><br><span class="line">            s[i]=temp;</span><br><span class="line">            <span class="comment">//swap(s[i],s[j])</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode-cn.com/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s.<span class="built_in">size</span>()<span class="number">-1</span>;i+=<span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+k&lt;=s.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">begin</span>()+i+k);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+i,s.<span class="built_in">begin</span>()+s.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> oldsize=s.<span class="built_in">size</span>();</span><br><span class="line">        s.<span class="built_in">resize</span>(oldsize+count*<span class="number">2</span>);</span><br><span class="line">        <span class="type">int</span> newsize=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=newsize<span class="number">-1</span>,j=oldsize<span class="number">-1</span>;j&lt;i;j--,i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                s[i]=s[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                s[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i<span class="number">-1</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i<span class="number">-2</span>]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                i-=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//从后往前填充避免了申请额外空间，也避免了从前往后填充需要将每个元素后移动</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="151-颠倒字符串中的单词"><a href="#151-颠倒字符串中的单词" class="headerlink" title="151. 颠倒字符串中的单词"></a><strong><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">151. 颠倒字符串中的单词</a></strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">#### [剑指 Offer <span class="number">58</span> - II. 左旋转字符串](https:<span class="comment">//leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)</span></span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="comment">//左旋不使用额外辅助空间</span></span><br><span class="line"><span class="comment">//反转区间为前n的子串</span></span><br><span class="line"><span class="comment">//反转区间为n到末尾的子串</span></span><br><span class="line"><span class="comment">//反转整个字符串</span></span><br><span class="line"><span class="comment">//reverse函数左闭右开</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string <span class="built_in">reverseLeftWords</span>(string s, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">begin</span>()+n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>()+n,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><strong><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></strong></h4><p>在一个串中查找是否出现过另一个串，想到kmp。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(<span class="type">const</span> string &amp;p)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> m=p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;p[i]!=p[j])&#123;</span><br><span class="line">                j=prefix[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[i]==p[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            prefix[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> n=haystack.<span class="built_in">size</span>();<span class="type">int</span> m=needle.<span class="built_in">size</span>();</span><br><span class="line">       <span class="keyword">if</span> (m==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next=<span class="built_in">prefix</span>(needle);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;haystack[i]!=needle[j])&#123;</span><br><span class="line">               j=next[j<span class="number">-1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(haystack[i]==needle[j])&#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">               <span class="keyword">return</span> i-m+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><strong><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459. 重复的子字符串</a></strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getnext</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j])&#123;</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next=<span class="built_in">getnext</span>(s);</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next[n<span class="number">-1</span>]!=<span class="number">0</span>&amp;&amp;n%(n-next[n<span class="number">-1</span>])==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;344. 反转字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-string/&quot;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="http://github.com/2022/05/02/Binary-Search/"/>
    <id>http://github.com/2022/05/02/Binary-Search/</id>
    <published>2022-05-02T04:52:35.000Z</published>
    <updated>2022-05-02T12:53:09.192Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">BinarySearchIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target ,<span class="type">bool</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> result=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">          <span class="type">int</span>  mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                result = mid;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="comment">//flag 为true 继续查找左边界</span></span><br><span class="line">                    right=mid<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftborder=<span class="built_in">BinarySearchIndex</span>(nums,target,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(leftborder==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> rightborder=<span class="built_in">BinarySearchIndex</span>(nums,target,<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;leftborder,rightborder&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根 </a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r=x;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)mid*mid &lt;= x)&#123;</span><br><span class="line">                res=mid;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="367-有效的完全平方数"><a href="#367-有效的完全平方数" class="headerlink" title="367. 有效的完全平方数"></a><a href="https://leetcode-cn.com/problems/valid-perfect-square/">367. 有效的完全平方数</a></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r=num;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=l+(r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span>)mid*mid==num)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)mid*mid&lt;num)&#123;</span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; </span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot;&gt;34.在排序数组中查找元素的第一个和最后一个位置&lt;/a&gt;&lt;/p&gt;
&lt;fig</summary>
      
    
    
    
    
    <category term="算法" scheme="http://github.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://github.com/2022/04/19/%E9%93%BE%E8%A1%A8/"/>
    <id>http://github.com/2022/04/19/%E9%93%BE%E8%A1%A8/</id>
    <published>2022-04-19T10:58:19.000Z</published>
    <updated>2022-04-19T11:01:30.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><p>单链表</p></li><li><p>双链表</p></li><li><p>循环链表：可以用于解决约瑟夫环问题</p><p><strong>链表定义</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不定义构造函数也行，c++会默认生成一个构造函数，但不会初始化任何成员变量</span></span><br><span class="line"></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);<span class="comment">//通过自己定义的构造初始化</span></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;<span class="comment">//使用默认构造初始化结点，初始化的时候不能直接给变量赋值。</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203.移除链表元素</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代  为了便于删除 添加一个头节点。</span></span><br><span class="line"><span class="comment">//t:O(n) v:O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *_head= <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode * nhead=_head;</span><br><span class="line">        <span class="keyword">while</span>(nhead-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nhead-&gt;next-&gt;val==val)&#123;</span><br><span class="line">              nhead-&gt;next=nhead-&gt;next-&gt;next; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nhead=nhead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/design-linked-list/">707.设计链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LNode *next;</span><br><span class="line">        <span class="built_in">LNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyhead=<span class="keyword">new</span> <span class="built_in">LNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">index</span>&lt;<span class="number">0</span>||index&gt;(_size<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cur=_dummyhead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> newnode=<span class="keyword">new</span> <span class="built_in">LNode</span>(val);</span><br><span class="line">        newnode-&gt;next=_dummyhead-&gt;next;</span><br><span class="line">        _dummyhead-&gt;next=newnode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> newnode=<span class="keyword">new</span> <span class="built_in">LNode</span>(val);</span><br><span class="line">        <span class="keyword">auto</span> cur=_dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next=newnode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index&gt;_size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> newnode=<span class="keyword">new</span> <span class="built_in">LNode</span>(val);</span><br><span class="line">        <span class="keyword">auto</span> cur=_dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        newnode-&gt;next=cur-&gt;next;</span><br><span class="line">        cur-&gt;next=newnode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=_size||index&lt;<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> cur=_dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    LNode * _dummyhead;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206.反转链表</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代 双指针法 t:O(n) v:O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        ListNode* pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=pre;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//递归</span></span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24.两两交换链表中的节点</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代 注意画图 t:O(n) v:O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode * cur=dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            ListNode *tmp1=cur-&gt;next;</span><br><span class="line">            ListNode *tmp3=cur-&gt;next-&gt;next-&gt;next; </span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next=tmp1;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next=tmp3;</span><br><span class="line"></span><br><span class="line">            cur=cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第N个节点</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针 O(n) O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode * dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode *slow = dummyHead;</span><br><span class="line">        ListNode *fast=dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(n--&amp;&amp;fast!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=fast-&gt;next;</span><br><span class="line">        <span class="comment">//fast先走了n+1步</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">02.07.链表相交</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.双指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA==<span class="literal">nullptr</span>||headB==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> *p=headA;</span><br><span class="line">        <span class="keyword">auto</span> *q=headB;</span><br><span class="line">        <span class="keyword">while</span>(p!=q)&#123;</span><br><span class="line">            p==<span class="literal">nullptr</span>?p=headB:p=p-&gt;next;</span><br><span class="line">            q==<span class="literal">nullptr</span>?q=headA:q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142 .环形链表II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先判断有没有环  hash或者快慢指针</span></span><br><span class="line"><span class="comment">//如果有环，找入口。 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> slow = head;</span><br><span class="line">        <span class="keyword">auto</span> fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">            <span class="comment">//有环</span></span><br><span class="line">            <span class="keyword">auto</span> index1=slow;</span><br><span class="line">            <span class="keyword">auto</span> index2=head;</span><br><span class="line">            <span class="keyword">while</span>(index1!=index2)&#123;</span><br><span class="line">                index1=index1-&gt;next;</span><br><span class="line">                index2=index2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单链表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;双链表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;循环链表：可以用于解决约瑟夫环问题&lt;/</summary>
      
    
    
    
    <category term="算法" scheme="http://github.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>并发与多线程</title>
    <link href="http://github.com/2022/03/31/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://github.com/2022/03/31/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-03-31T08:59:40.000Z</published>
    <updated>2022-04-01T03:59:03.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并发、进程、线程的基本概念"><a href="#并发、进程、线程的基本概念" class="headerlink" title="并发、进程、线程的基本概念"></a>并发、进程、线程的基本概念</h3><hr><p>1.并发</p><p>​    多个任务(独立的活动)同时发生。早期计算机只有一个CPU，为了同时间执行多个任务，我们规定在一定的时间间隔内执行程序，这样就可以在宏观上达到并行执行程序，但实际微观上是隔很短的时间不停的切换执行程序，这样看起来就像很多程序同时执行一样。</p><p>2.可执行文件</p><p>win下是.exe ,Linux下有可执行权限的文件。 rwx  x代表可执行权限。</p><p>3.进程</p><p>可执行程序运行起来就是一个进程。一个运行的程序的过程就是进程</p><p>4.线程</p><ul><li>每个进程有且只有一个主线程。</li><li>运行一个可执行程序，产生一个进程后，这个主线程也随之默默启动起来了</li></ul><h3 id="并发的实现"><a href="#并发的实现" class="headerlink" title="并发的实现"></a>并发的实现</h3><hr><p>1.多进程并发</p><p>进程之间可以使用管道、文件、消息队列、共享内存等技术实现通信。</p><p>2.多线程并发</p><p>在单独的一个进程中创建多个线程来实现并发。一个进程中的所有线程共享地址空间(共享内存).全局变量、指针、引用都可以在线程之间传递。</p><p>多线程使用共享内存虽然灵活，但是也带来了新的问题——数据一致性问题。例如，线程A要写一块数据，B也要写这块数据。同时去写会造成互相覆盖等数据不一致的错误。因此需要采取一定的技术手段，让他们有先后地去写。</p><p>3.总结对比</p><p>线程启动速度更快，更轻量级，系统资源开销更小，执行速度更快。</p><p>多线程使用起来有难度，要注意处理数据的一致性问题。</p><h3 id="C-11线程库"><a href="#C-11线程库" class="headerlink" title="C++11线程库"></a>C++11线程库</h3><p>可以跨平台。POSIX thread(pthread)也可以跨平台。但是都需要配置，也不方便</p><p>1.线程启动，结束与创建线程写法。</p><p>主线程从main主函数开始执行，main结束了，主线程也就结束了，进程也就结束了。如果其他子线程没结束，会被操作系统强制终止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprintf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;子线程创建了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;子线程关闭了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread1</span><span class="params">(myprintf)</span></span>;<span class="comment">//myprintf作为构造函数参数</span></span><br><span class="line">    thread1.<span class="built_in">join</span>();<span class="comment">//main主线程阻塞等待子线程执行</span></span><br><span class="line">  <span class="comment">//thread1.detach();</span></span><br><span class="line">  <span class="comment">//主线程不会等待子线程。  //调用了detach就不可以调用join了。detach类似linux中的守护进程</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main执行完毕&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）thread<br>一个类。构造函数的参数是一个可调用对象（此处可调用对象就是函数myprint）作为thread构造函数的实参来构造这个thread对象。<br>（2）join<br>阻塞函数，让main主线程等待子线程执行。（主线程结束，子线程会被强制结束）<br>（3）detach<br>分离函数，让main主线程不等待子线程执行。<br>（4）joinable<br>bool res&#x3D;thread1.joinable();&#x2F;&#x2F;true为调用过。<br>判断某个线程是否调用过join或者detach函数。</p><h3 id="其他创建线程的写法"><a href="#其他创建线程的写法" class="headerlink" title="其他创建线程的写法"></a>其他创建线程的写法</h3><p>1.用类来创建线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TA::operator()开始执行了&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TA::operator()执行结束了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TA ta;</span><br><span class="line">    <span class="function">thread <span class="title">mth</span><span class="params">(ta)</span></span>;<span class="comment">//ta,可调用对象，不可以是临时对象thread mth(TA())</span></span><br><span class="line">    <span class="comment">//否则编译无法通过</span></span><br><span class="line">    mth.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main函数执行结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*使用detach后，当main函数执行结束后，</span></span><br><span class="line"><span class="comment">*很可能子线程还在访问主线程里面的*my_i，</span></span><br><span class="line"><span class="comment">*这个时候my_i早已被释放，子线程仍</span></span><br><span class="line"><span class="comment">*旧使用被销毁的ny_i，产生不可预料的</span></span><br><span class="line"><span class="comment">*后果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>&amp; m_i;</span><br><span class="line">    <span class="built_in">TA</span>(<span class="type">int</span>&amp; i):<span class="built_in">m_i</span>(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi1的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi2的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi3的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi4的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi5的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi6的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi7的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi8的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi9的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> my_i = <span class="number">6</span>;</span><br><span class="line">    <span class="function">TA <span class="title">ta</span><span class="params">(my_i)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myTObj</span><span class="params">(ta)</span></span>;</span><br><span class="line">    myTObj.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">//main函数执行太快，延缓main，让线程函数执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        q = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main主函数执行结束了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.用lambda表达式来创建线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> mylambdathread=[]&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;我的线程开始了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;我的线程执行完毕了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">mth</span><span class="params">(mylambdathread)</span></span>;</span><br><span class="line">    mth.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main函数执行结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程传参、detach坑与成员函数作为线程函数"><a href="#线程传参、detach坑与成员函数作为线程函数" class="headerlink" title="线程传参、detach坑与成员函数作为线程函数"></a>线程传参、detach坑与成员函数作为线程函数</h3><p><strong>传递临时对象作为线程参数</strong></p><ul><li><p>陷阱1</p><p>如果用detach这种方式创建线程、不要往线程中传递引用、指针之类的参数。（p506）</p><p>主线程已经运行结束，资源已经释放，但是子线程仍然在调用主线程资源。</p></li><li><p>陷阱2</p><p>传递的参数隐式转换时，还未来的及转换转换，资源就被释放。</p></li><li><p>总结</p><ul><li>如果传递int这种简单类型参数，建议都使用值传递，不要使用引用类型。</li><li>如果传递类对象作为参数，则避免隐式类型转换(如把一个char *转成string,把一个int转成类A对象)，全部都在创建线程这一行就构建出临时对象来，然后线程入口函数的形参位置使用引用来作为形参。避免主线程退出导致子线程对内存的非法引用。</li><li>建议不使用detach，只使用join，这样就不存在局部变量失效导致线程对内存非法引用的问题。</li></ul></li><li><p>线程id</p></li></ul><p>​    C++标准库里的函数std::this_thread::get_id可以获取线程i</p><hr><p><strong>传递类对象与智能指针作为线程参数</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;并发、进程、线程的基本概念&quot;&gt;&lt;a href=&quot;#并发、进程、线程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;并发、进程、线程的基本概念&quot;&gt;&lt;/a&gt;并发、进程、线程的基本概念&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1.并发&lt;/p&gt;
&lt;p&gt;​    多个任务</summary>
      
    
    
    
    
    <category term="C++新经典note" scheme="http://github.com/tags/C-%E6%96%B0%E7%BB%8F%E5%85%B8note/"/>
    
  </entry>
  
  <entry>
    <title>new/delete and malloc/free</title>
    <link href="http://github.com/2022/03/23/new-delete-and-malloc-free/"/>
    <id>http://github.com/2022/03/23/new-delete-and-malloc-free/</id>
    <published>2022-03-23T13:58:36.000Z</published>
    <updated>2022-03-23T14:00:44.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-x2F-delete和malloc-x2F-free的区别"><a href="#new-x2F-delete和malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free的区别"></a>new&#x2F;delete和malloc&#x2F;free的区别</h3><ol><li><p>new是关键字（也是操作符），需要编译器支持，malloc是库函数，需要头文件支持。</p></li><li><p>参数。new申请内存空间不需要指定大小，malloc需要显示的指定内存大小。</p></li><li><p>返回类型。new分配内存成功返回的是对象类型的指针，不需要类型转换，new是符合类型安全性的操作符。malloc内存分配成功返回void*,需要强制类型转换，将void*指针转换成我们需要的类型。</p></li><li><p>分配失败。new分配失败抛出bac_alloc异常。malloc返回NULL。</p></li><li><p>自定义类型。new会先调用operator new函数申请足够的内存(底层由malloc实现)。然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构，在调用operator delete函数释放内存(通常底层使用free实现)。malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></li><li><p>重载。new&#x2F;delete可以操作符重载，malloc不行</p></li><li><p>内存区域。new操作符从自由存储区(free store)上为对象动态分配内存空间，而malloc函数是从堆区分配内存。</p></li></ol><hr><h4 id="Free-Store-VS-Heap"><a href="#Free-Store-VS-Heap" class="headerlink" title="Free Store VS Heap"></a>Free Store VS Heap</h4><p>C++中，内存分为堆，栈，自由存储区，全局&#x2F;静态存储区，常量存储区。<br>堆是C和OS的术语，因为基本上所有的C++编译器默认使用堆来实现自由存储，即缺省的new和delete由malloc和free实现，这时候new分配的对象，说它在堆上也对，自由存储区也对（此时heap&#x3D;free store)。但如果使用操作符重载的方式，改用其他内存实现自由存储。这时候new的对象就在自由存储区，而不是堆了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-x2F-delete和malloc-x2F-free的区别&quot;&gt;&lt;a href=&quot;#new-x2F-delete和malloc-x2F-free的区别&quot; class=&quot;headerlink&quot; title=&quot;new&amp;#x2F;delete和malloc&amp;#x2</summary>
      
    
    
    
    <category term="C++" scheme="http://github.com/categories/C/"/>
    
    
  </entry>
  
</feed>
