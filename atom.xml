<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Je2ry&#39;s Blog</title>
  
  
  <link href="http://github.com/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2022-04-14T05:31:58.775Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Je2ry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node.js学习</title>
    <link href="http://github.com/2022/04/12/node-js%E5%AD%A6%E4%B9%A0/"/>
    <id>http://github.com/2022/04/12/node-js%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-04-12T02:16:35.000Z</published>
    <updated>2022-04-14T05:31:58.775Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-浏览器中的Javascript组成部分"><a href="#1-浏览器中的Javascript组成部分" class="headerlink" title="1. 浏览器中的Javascript组成部分"></a>1. 浏览器中的Javascript组成部分</h3><p>Js核心语法+WebAPI(Dom、Bom、Ajax)</p><p> Js解析引擎:</p><ul><li>Chrome &#x3D;&gt; v8(性能最好)</li><li>Firefox &#x3D;&gt; OdinMonkey</li><li>Safri &#x3D;&gt; JSCore</li><li>IE &#x3D;&gt; Chakra</li></ul><p><strong>Q:为什么Js可以操作DOM和BOM</strong></p><p>A：每个浏览器内置了DOM、BOM这样的API,Js可以调用。</p><p>node.js也是一个运行环境,借助于node.js,javascript可以用来做后端开发。</p><p>Node.js is  a &#x3D;&#x3D;JavaScript runtime&#x3D;&#x3D; built on Chrome’s V8 JavaScript engine</p><p><a href="https://nodejs.org/zh-cn/">官网地址</a></p><p> 注意：</p><ol><li>&#x3D;&#x3D;浏览器&#x3D;&#x3D;是JavaScript的&#x3D;&#x3D;前端运行环境&#x3D;&#x3D;。</li><li>&#x3D;&#x3D;Node.js&#x3D;&#x3D;是JavaScript的&#x3D;&#x3D;后端运行环境&#x3D;&#x3D;。</li><li>Node.js中&#x3D;&#x3D;无法调用&#x3D;&#x3D;DOM和BOM等&#x3D;&#x3D;浏览器内置API&#x3D;&#x3D;</li></ol><p>应用：</p><pre><code>        1. 基于Express框架,可以构建Web应用           2. 基于Electron框架,可以构建跨平台的桌面应用           3. 基于restify框架,可以快速构建API接口项目           4. 读写和操作DB、etc...</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node  filename.<span class="property">js</span><span class="comment">//执行</span></span><br></pre></td></tr></table></figure><h3 id="2-fs-文件系统模块"><a href="#2-fs-文件系统模块" class="headerlink" title="2. fs 文件系统模块"></a>2. fs 文件系统模块</h3><p>fs 模块是用来操作文件的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)<span class="comment">//要用到fs的时候需要以这种方式导入</span></span><br></pre></td></tr></table></figure><ul><li>fs.readFile() 读取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(path[,options],callback)</span><br><span class="line"><span class="comment">//参数1 必选参数 字符串，文件路径</span></span><br><span class="line"><span class="comment">//参数2 可选   以什么编码格式来读取文件</span></span><br><span class="line"><span class="comment">//参数3 必选参数 文件读取完成后，通过回调函数拿到读取的结果 </span></span><br><span class="line"><span class="comment">//可以判断err对象是否为null,从而知晓文件读取的结果。</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;filepath&#x27;</span>,<span class="string">&#x27;utf8&#x27;</span>,<span class="keyword">function</span>(<span class="params">err,dataStr</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取文件失败!&#x27;</span>+err.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取成功&#x27;</span>+dataStr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>fs.writeFile() 写入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(file,data[,options],callback) </span><br><span class="line"><span class="comment">//参数1:必选  文件存放路径字符串</span></span><br><span class="line"><span class="comment">//参数2:必选 写入的内容</span></span><br><span class="line"><span class="comment">//参数3:可选 格式 默认 utf8</span></span><br><span class="line"><span class="comment">//参数4:必选 回调函数</span></span><br><span class="line"><span class="comment">//这种写入是覆盖   追加用 appendFile</span></span><br></pre></td></tr></table></figure><p><strong>路径动态拼接的问题</strong></p><p>代码运行时，会以执行node命令时所处的目录、动态拼接出被操作文件的完整路径。所以使用相对路径容易出现动态拼接错误问题，但如果使用绝对路径，移植性非常差，不利于维护。</p><p>__dirname 表示当前文件所处的目录(双下划线)  ，因此可以解决上述两个问题。</p><h3 id="3-path路径模块"><a href="#3-path路径模块" class="headerlink" title="3. path路径模块"></a>3. path路径模块</h3><p>path模块时用来处理路径的模块，使用前也需要先导入</p><ul><li><p>path.join()方法,用来将对多个路径片段拼接成一个完整的路径字符串。</p><p>该方法相对于直接用+拼接，会处理’.&#x2F;‘不容易出错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="keyword">const</span> pathStr =path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>,<span class="string">&#x27;/b/c&#x27;</span>,<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;./d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr)<span class="comment">//输出\a\b\d\e</span></span><br><span class="line"><span class="keyword">const</span> pathStr2= path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./files/1.txt&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr2)<span class="comment">//输出当前文件所处目录\files\1.txt</span></span><br></pre></td></tr></table></figure></li><li><p>path.basename()方法，用来从路径字符串中，将文件名解析出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">basename</span>(path[,ext])</span><br><span class="line"><span class="comment">//path &lt;string&gt;必选参数，表示一个路径的字符串</span></span><br><span class="line"><span class="comment">//ext &lt;string&gt;可选，表示文件扩展名</span></span><br><span class="line"><span class="comment">//返回:&lt;string&gt;表示路径中的最后一部分</span></span><br><span class="line"><span class="keyword">const</span> fpath= <span class="string">&#x27;/a/b/c/index.html&#x27;</span></span><br><span class="line"><span class="keyword">const</span> fullName = path.<span class="title function_">basename</span>(fpath)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName) <span class="comment">//输出index.html</span></span><br><span class="line">path.<span class="title function_">basebame</span>(fpath,<span class="string">&#x27;.html&#x27;</span>)<span class="comment">//则log输出index</span></span><br></pre></td></tr></table></figure></li><li><p>path.extname()  获取路径中的文件扩展名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">extname</span>(path)</span><br><span class="line"></span><br><span class="line"><span class="comment">//正则匹配&lt;style&gt;&lt;/style&gt; 标签</span></span><br><span class="line"><span class="keyword">const</span> regStyle = <span class="regexp">/&lt;style&gt;[\s\S]*&lt;\/style&gt;/</span></span><br><span class="line"><span class="comment">// ====/s/S  空白和非空白字符</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-正则匹配"><a href="#4-正则匹配" class="headerlink" title="4. 正则匹配"></a>4. 正则匹配</h3><p>exec()方法用于检索字符串中的正则表达式的匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">RegExpObject</span>.<span class="title function_">exec</span>(string)</span><br><span class="line"><span class="comment">//string 必须，要检索的字符串</span></span><br><span class="line"><span class="comment">//返回一个数组，存放匹配的结果，未找到匹配，返回null</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-浏览器中的Javascript组成部分&quot;&gt;&lt;a href=&quot;#1-浏览器中的Javascript组成部分&quot; class=&quot;headerlink&quot; title=&quot;1. 浏览器中的Javascript组成部分&quot;&gt;&lt;/a&gt;1. 浏览器中的Javascript组成部分</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>并发与多线程</title>
    <link href="http://github.com/2022/03/31/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://github.com/2022/03/31/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-03-31T08:59:40.000Z</published>
    <updated>2022-04-01T03:59:03.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并发、进程、线程的基本概念"><a href="#并发、进程、线程的基本概念" class="headerlink" title="并发、进程、线程的基本概念"></a>并发、进程、线程的基本概念</h3><hr><p>1.并发</p><p>​    多个任务(独立的活动)同时发生。早期计算机只有一个CPU，为了同时间执行多个任务，我们规定在一定的时间间隔内执行程序，这样就可以在宏观上达到并行执行程序，但实际微观上是隔很短的时间不停的切换执行程序，这样看起来就像很多程序同时执行一样。</p><p>2.可执行文件</p><p>win下是.exe ,Linux下有可执行权限的文件。 rwx  x代表可执行权限。</p><p>3.进程</p><p>可执行程序运行起来就是一个进程。一个运行的程序的过程就是进程</p><p>4.线程</p><ul><li>每个进程有且只有一个主线程。</li><li>运行一个可执行程序，产生一个进程后，这个主线程也随之默默启动起来了</li></ul><h3 id="并发的实现"><a href="#并发的实现" class="headerlink" title="并发的实现"></a>并发的实现</h3><hr><p>1.多进程并发</p><p>进程之间可以使用管道、文件、消息队列、共享内存等技术实现通信。</p><p>2.多线程并发</p><p>在单独的一个进程中创建多个线程来实现并发。一个进程中的所有线程共享地址空间(共享内存).全局变量、指针、引用都可以在线程之间传递。</p><p>多线程使用共享内存虽然灵活，但是也带来了新的问题——数据一致性问题。例如，线程A要写一块数据，B也要写这块数据。同时去写会造成互相覆盖等数据不一致的错误。因此需要采取一定的技术手段，让他们有先后地去写。</p><p>3.总结对比</p><p>线程启动速度更快，更轻量级，系统资源开销更小，执行速度更快。</p><p>多线程使用起来有难度，要注意处理数据的一致性问题。</p><h3 id="C-11线程库"><a href="#C-11线程库" class="headerlink" title="C++11线程库"></a>C++11线程库</h3><p>可以跨平台。POSIX thread(pthread)也可以跨平台。但是都需要配置，也不方便</p><p>1.线程启动，结束与创建线程写法。</p><p>主线程从main主函数开始执行，main结束了，主线程也就结束了，进程也就结束了。如果其他子线程没结束，会被操作系统强制终止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprintf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;子线程创建了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;子线程关闭了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">thread1</span><span class="params">(myprintf)</span></span>;<span class="comment">//myprintf作为构造函数参数</span></span><br><span class="line">    thread1.<span class="built_in">join</span>();<span class="comment">//main主线程阻塞等待子线程执行</span></span><br><span class="line">  <span class="comment">//thread1.detach();</span></span><br><span class="line">  <span class="comment">//主线程不会等待子线程。  //调用了detach就不可以调用join了。detach类似linux中的守护进程</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main执行完毕&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）thread<br>一个类。构造函数的参数是一个可调用对象（此处可调用对象就是函数myprint）作为thread构造函数的实参来构造这个thread对象。<br>（2）join<br>阻塞函数，让main主线程等待子线程执行。（主线程结束，子线程会被强制结束）<br>（3）detach<br>分离函数，让main主线程不等待子线程执行。<br>（4）joinable<br>bool res&#x3D;thread1.joinable();&#x2F;&#x2F;true为调用过。<br>判断某个线程是否调用过join或者detach函数。</p><h3 id="其他创建线程的写法"><a href="#其他创建线程的写法" class="headerlink" title="其他创建线程的写法"></a>其他创建线程的写法</h3><p>1.用类来创建线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TA::operator()开始执行了&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;TA::operator()执行结束了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TA ta;</span><br><span class="line">    <span class="function">thread <span class="title">mth</span><span class="params">(ta)</span></span>;<span class="comment">//ta,可调用对象，不可以是临时对象thread mth(TA())</span></span><br><span class="line">    <span class="comment">//否则编译无法通过</span></span><br><span class="line">    mth.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main函数执行结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*使用detach后，当main函数执行结束后，</span></span><br><span class="line"><span class="comment">*很可能子线程还在访问主线程里面的*my_i，</span></span><br><span class="line"><span class="comment">*这个时候my_i早已被释放，子线程仍</span></span><br><span class="line"><span class="comment">*旧使用被销毁的ny_i，产生不可预料的</span></span><br><span class="line"><span class="comment">*后果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TA</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>&amp; m_i;</span><br><span class="line">    <span class="built_in">TA</span>(<span class="type">int</span>&amp; i):<span class="built_in">m_i</span>(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi1的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi2的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi3的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi4的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi5的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi6的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi7的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi8的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;mi9的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> my_i = <span class="number">6</span>;</span><br><span class="line">    <span class="function">TA <span class="title">ta</span><span class="params">(my_i)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">myTObj</span><span class="params">(ta)</span></span>;</span><br><span class="line">    myTObj.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">//main函数执行太快，延缓main，让线程函数执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> q;</span><br><span class="line">        q = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main主函数执行结束了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.用lambda表达式来创建线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">auto</span> mylambdathread=[]&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;我的线程开始了&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;我的线程执行完毕了&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">mth</span><span class="params">(mylambdathread)</span></span>;</span><br><span class="line">    mth.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main函数执行结束&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程传参、detach坑与成员函数作为线程函数"><a href="#线程传参、detach坑与成员函数作为线程函数" class="headerlink" title="线程传参、detach坑与成员函数作为线程函数"></a>线程传参、detach坑与成员函数作为线程函数</h3><p><strong>传递临时对象作为线程参数</strong></p><ul><li><p>陷阱1</p><p>如果用detach这种方式创建线程、不要往线程中传递引用、指针之类的参数。（p506）</p><p>主线程已经运行结束，资源已经释放，但是子线程仍然在调用主线程资源。</p></li><li><p>陷阱2</p><p>传递的参数隐式转换时，还未来的及转换转换，资源就被释放。</p></li><li><p>总结</p><ul><li>如果传递int这种简单类型参数，建议都使用值传递，不要使用引用类型。</li><li>如果传递类对象作为参数，则避免隐式类型转换(如把一个char *转成string,把一个int转成类A对象)，全部都在创建线程这一行就构建出临时对象来，然后线程入口函数的形参位置使用引用来作为形参。避免主线程退出导致子线程对内存的非法引用。</li><li>建议不使用detach，只使用join，这样就不存在局部变量失效导致线程对内存非法引用的问题。</li></ul></li><li><p>线程id</p></li></ul><p>​    C++标准库里的函数std::this_thread::get_id可以获取线程i</p><hr><p><strong>传递类对象与智能指针作为线程参数</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;并发、进程、线程的基本概念&quot;&gt;&lt;a href=&quot;#并发、进程、线程的基本概念&quot; class=&quot;headerlink&quot; title=&quot;并发、进程、线程的基本概念&quot;&gt;&lt;/a&gt;并发、进程、线程的基本概念&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;1.并发&lt;/p&gt;
&lt;p&gt;​    多个任务</summary>
      
    
    
    
    
    <category term="C++新经典note" scheme="http://github.com/tags/C-%E6%96%B0%E7%BB%8F%E5%85%B8note/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记</title>
    <link href="http://github.com/2022/03/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://github.com/2022/03/29/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-29T14:28:57.000Z</published>
    <updated>2022-03-30T10:31:10.158Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>704 二分查找]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分  O(logN) O(1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left,right,mid;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;nums[mid])</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>278 第一个错误的版本</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right=n;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;<span class="comment">//防溢出</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isBadVersion</span>(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>35 搜索插入位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left,right,mid;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right=mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>977 有序数组的平方</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//双指针   O(N)   O(1)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>,pos=n<span class="number">-1</span>;i&lt;=j;)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])</span><br><span class="line">           &#123;</span><br><span class="line">               ans[pos]=nums[i]*nums[i];</span><br><span class="line">               ++i;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               ans[pos]=nums[j]*nums[j];</span><br><span class="line">               --j;</span><br><span class="line">           &#125;</span><br><span class="line">           --pos;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//暴力   O(NlogN)  O(logN)</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(num * num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());<span class="comment">//sort是快排的优化。O(nlogn)</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>344 反转字符串</li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;i&lt;=j;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> tmp=s[i];</span><br><span class="line">            s[i]=s[j];</span><br><span class="line">            s[j]=tmp;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//双指针   可直接用swap()函数。</span></span><br></pre></td></tr></table></figure><ol start="6"><li><p>27 移除元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快慢指针 O(N) O(1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>;fast&lt;nums.<span class="built_in">size</span>();fast++)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(val!=nums[fast])</span><br><span class="line">             nums[slow++]=nums[fast];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209长度最小的子数组</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解法 O(n^2) O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> s, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和</span></span><br><span class="line">        <span class="type">int</span> subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                    subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                    result = result &lt; subLength ? result : subLength;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//滑动窗口 O(N) O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT32_MAX;</span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;   sum+=nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)</span><br><span class="line">            &#123;   length=j-i+<span class="number">1</span>;</span><br><span class="line">                res=res&lt;length?res:length;</span><br><span class="line">                sum-=nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==INT32_MAX?<span class="number">0</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59 螺旋矩阵II</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><hr><ol start="9"><li><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203 移除链表元素</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代  O(N)   O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode * vhead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        ListNode *p=vhead;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val==val)&#123;</span><br><span class="line">        </span><br><span class="line">                p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>理论基础</li></ol><ul><li>数组是存放在连续内存空间上的相同类型数据的集合</li><li>数组下标都是从0开始的。</li><li>数组内存空间的地址是连续的，删除或者增添元素的时候，就难免要移动其他元素的地址。</li><li>数组的元素是不能删的，只能覆盖。</li><li>C++中二维数组的在地址空间上是连续的,java不是。</li></ul><ol start="2"><li><p>二分查找</p><p>数组为<strong>有序数组</strong>，同时题目还强调数组中<strong>无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件。</p><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right]</strong></p><p>while(left&lt;&#x3D;right)</p><p>第二种写法，定义 target 是在一个在左闭右开的区间里，也就是[left, right) </p><p>while(left&lt;right)</p><p>相关题目:35(A). 34. 69. 367.</p></li><li><p>双指针法（快慢指针法）在数组和链表的操作中是非常常见的，很多考察数组、链表、字符串等操作的面试题，都使用双指针法。</p><p>相关题目:26. 283. 844. 977.(A) </p></li><li><p><strong>滑动窗口</strong></p><p>​    所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>相关题目:904.76.209.(A)</p></li><li><p>模拟类题目</p><p>相关题目:54. 59. 剑指29.</p></li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li><p>单链表</p></li><li><p>双链表</p></li><li><p>循环链表：可以用于解决约瑟夫环问题</p><p><strong>链表定义</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//不定义构造函数也行，c++会默认生成一个构造函数，但不会初始化任何成员变量</span></span><br><span class="line"></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);<span class="comment">//通过自己定义的构造初始化</span></span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">head-&gt;val = <span class="number">5</span>;<span class="comment">//使用默认构造初始化结点，初始化的时候不能直接给变量赋值。</span></span><br></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><strong>满二叉树</strong></p><p>如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p><strong>完全二叉树</strong></p><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</p><p>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</p><p><strong>二叉搜索树</strong></p><p>二叉搜索树是一个有序树。</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><p><strong>平衡二叉树</strong></p><p>AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。</p><p><strong>存储方式</strong></p><p><strong>二叉树可以链式存储，也可以顺序存储。</strong></p><p>那么链式存储方式就用指针， 顺序存储的方式就是用数组。</p><p>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。</p><p>用数组来存储二叉树如何遍历的呢？</p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><p><strong>遍历方式</strong></p><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的去遍历。</li></ol><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p><strong>二叉树的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;704 二分查找]&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="C++" scheme="http://github.com/categories/C/"/>
    
    <category term="Algorithm" scheme="http://github.com/categories/C/Algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>new/delete and malloc/free</title>
    <link href="http://github.com/2022/03/23/new-delete-and-malloc-free/"/>
    <id>http://github.com/2022/03/23/new-delete-and-malloc-free/</id>
    <published>2022-03-23T13:58:36.000Z</published>
    <updated>2022-03-23T14:00:44.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-x2F-delete和malloc-x2F-free的区别"><a href="#new-x2F-delete和malloc-x2F-free的区别" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free的区别"></a>new&#x2F;delete和malloc&#x2F;free的区别</h3><ol><li><p>new是关键字（也是操作符），需要编译器支持，malloc是库函数，需要头文件支持。</p></li><li><p>参数。new申请内存空间不需要指定大小，malloc需要显示的指定内存大小。</p></li><li><p>返回类型。new分配内存成功返回的是对象类型的指针，不需要类型转换，new是符合类型安全性的操作符。malloc内存分配成功返回void*,需要强制类型转换，将void*指针转换成我们需要的类型。</p></li><li><p>分配失败。new分配失败抛出bac_alloc异常。malloc返回NULL。</p></li><li><p>自定义类型。new会先调用operator new函数申请足够的内存(底层由malloc实现)。然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构，在调用operator delete函数释放内存(通常底层使用free实现)。malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></li><li><p>重载。new&#x2F;delete可以操作符重载，malloc不行</p></li><li><p>内存区域。new操作符从自由存储区(free store)上为对象动态分配内存空间，而malloc函数是从堆区分配内存。</p></li></ol><hr><h4 id="Free-Store-VS-Heap"><a href="#Free-Store-VS-Heap" class="headerlink" title="Free Store VS Heap"></a>Free Store VS Heap</h4><p>C++中，内存分为堆，栈，自由存储区，全局&#x2F;静态存储区，常量存储区。<br>堆是C和OS的术语，因为基本上所有的C++编译器默认使用堆来实现自由存储，即缺省的new和delete由malloc和free实现，这时候new分配的对象，说它在堆上也对，自由存储区也对（此时heap&#x3D;free store)。但如果使用操作符重载的方式，改用其他内存实现自由存储。这时候new的对象就在自由存储区，而不是堆了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-x2F-delete和malloc-x2F-free的区别&quot;&gt;&lt;a href=&quot;#new-x2F-delete和malloc-x2F-free的区别&quot; class=&quot;headerlink&quot; title=&quot;new&amp;#x2F;delete和malloc&amp;#x2</summary>
      
    
    
    
    <category term="C++" scheme="http://github.com/categories/C/"/>
    
    
  </entry>
  
</feed>
