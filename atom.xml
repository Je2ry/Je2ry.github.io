<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Je2ry&#39;s Blog</title>
  
  
  <link href="http://github.com/atom.xml" rel="self"/>
  
  <link href="http://github.com/"/>
  <updated>2022-03-23T10:04:14.609Z</updated>
  <id>http://github.com/</id>
  
  <author>
    <name>Je2ry</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>new/delete vs malloc/free</title>
    <link href="http://github.com/2022/03/23/new-delete-vs-malloc-free/"/>
    <id>http://github.com/2022/03/23/new-delete-vs-malloc-free/</id>
    <published>2022-03-23T09:41:19.000Z</published>
    <updated>2022-03-23T10:04:14.609Z</updated>
    
    <content type="html"><![CDATA[<p>####new和malloc的区别<br>1.new是关键字（也是操作符），需要编译器支持，malloc是库函数，需要头文件支持<br>2.参数。new申请内存空间不需要指定大小，malloc需要显示的指定内存大小<br>3.返回类型。new分配内存成功返回的是对象类型的指针，不需要类型转换，new是符合类型安全性的操作符。malloc内存分配成功返回void*,需要强制类型转换，将void*指针转换成我们需要的类型。<br>3.分配失败。new分配失败抛出bac_alloc异常。malloc返回NULL<br>4.自定义类型。new会先调用operator new函数申请足够的内存(底层由malloc实现)。然后调用类的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构，在调用operator delete函数释放内存(通常底层使用free实现)。<br>    malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。<br>5.重载。new&#x2F;delete可以操作符重载，malloc不行<br>6.内存区域<br>new操作符从自由存储区(free store)上为对象动态分配内存空间，而malloc函数是从堆区分配内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;####new和malloc的区别&lt;br&gt;1.new是关键字（也是操作符），需要编译器支持，malloc是库函数，需要头文件支持&lt;br&gt;2.参数。new申请内存空间不需要指定大小，malloc需要显示的指定内存大小&lt;br&gt;3.返回类型。new分配内存成功返回的是对象类型的指</summary>
      
    
    
    
    <category term="C++" scheme="http://github.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Je2ry&#39;s Blog</title>
    <link href="http://github.com/2022/03/13/Je2ry-s-Blog/"/>
    <id>http://github.com/2022/03/13/Je2ry-s-Blog/</id>
    <published>2022-03-13T01:19:12.000Z</published>
    <updated>2022-03-13T01:19:12.376Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
